/**\n * Enhanced Dashboard App with Robust WebSocket Communication\n * Story 19.3 - WebSocket Communication Implementation\n */\n\nclass DashboardApp {\n  constructor() {\n    this.wsManager = null;\n    this.sessions = new Map();\n    this.selectedSessionId = null;\n    this.logBuffer = new Map();\n    this.filteredLogs = new Map();\n    this.autoScroll = true;\n    this.currentFilter = '';\n    this.logTypes = new Set(['stdout', 'stderr', 'info', 'warn', 'error', 'debug']);\n    this.connectionState = 'disconnected';\n    this.performanceMetrics = {\n      messagesReceived: 0,\n      lastMessageTime: null,\n      reconnections: 0,\n      connectionUptime: 0\n    };\n    this.notificationQueue = [];\n    this.maxNotifications = 5;\n    \n    this.initializeApp();\n  }\n  \n  async initializeApp() {\n    this.showLoadingState();\n    \n    try {\n      // Initialize enhanced WebSocket connection\n      await this.initializeWebSocket();\n      \n      // Bind all event listeners\n      this.bindEvents();\n      \n      // Start periodic updates\n      this.startPeriodicUpdates();\n      \n      // Load initial dashboard state\n      await this.loadInitialState();\n      \n      this.hideLoadingState();\n      \n      // Analytics initialization\n      this.trackEvent('dashboard_loaded', { timestamp: Date.now() });\n      \n    } catch (error) {\n      console.error('Failed to initialize dashboard:', error);\n      this.showErrorState('Failed to initialize dashboard: ' + error.message);\n    }\n  }\n  \n  /**\n   * Initialize enhanced WebSocket manager with robust features\n   */\n  async initializeWebSocket() {\n    // Initialize enhanced WebSocket manager\n    this.wsManager = new WebSocketManager({\n      autoReconnect: true,\n      maxReconnectAttempts: 10,\n      reconnectInterval: 1000,\n      maxReconnectInterval: 30000,\n      heartbeatInterval: 30000,\n      connectionTimeout: 10000,\n      messageQueueSize: 100\n    });\n    \n    // Setup event handlers\n    this.setupWebSocketEvents();\n    \n    // Connect to server\n    try {\n      await this.wsManager.connect();\n      console.log('Connected to MCP Debug Host with enhanced WebSocket manager');\n    } catch (error) {\n      console.error('Failed to connect to WebSocket:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Setup comprehensive WebSocket event handlers\n   */\n  setupWebSocketEvents() {\n    // Connection events\n    this.wsManager.on('connecting', (data) => {\n      this.connectionState = 'connecting';\n      this.updateConnectionStatus('connecting');\n      console.log('Connecting to WebSocket...', data);\n    });\n    \n    this.wsManager.on('connected', (data) => {\n      this.connectionState = 'connected';\n      this.updateConnectionStatus('connected');\n      this.performanceMetrics.lastMessageTime = Date.now();\n      \n      console.log('WebSocket connected:', data);\n      this.trackEvent('websocket_connected', data);\n      this.showNotification('Connected to MCP Debug Host', 'success');\n      \n      // Send enhanced handshake after connection\n      this.wsManager.send({\n        type: 'handshake',\n        payload: {\n          userAgent: navigator.userAgent,\n          timestamp: Date.now(),\n          version: '2.0.0',\n          capabilities: {\n            compression: true,\n            subscriptions: true,\n            messageQueue: true,\n            analytics: true\n          }\n        }\n      });\n    });\n    \n    this.wsManager.on('close', (data) => {\n      this.connectionState = 'disconnected';\n      this.updateConnectionStatus('disconnected');\n      console.log('WebSocket disconnected:', data);\n      \n      if (!data.wasClean) {\n        this.showNotification('Connection lost - attempting to reconnect...', 'warning');\n      }\n    });\n    \n    this.wsManager.on('reconnecting', (data) => {\n      this.connectionState = 'reconnecting';\n      this.updateConnectionStatus('reconnecting');\n      this.performanceMetrics.reconnections++;\n      \n      console.log(`Reconnecting... attempt ${data.attempt}/${data.maxAttempts}`);\n      this.trackEvent('websocket_reconnecting', data);\n      \n      const progress = Math.round((data.attempt / data.maxAttempts) * 100);\n      this.showNotification(`Reconnecting... (${progress}%) - Attempt ${data.attempt}`, 'info');\n    });\n    \n    this.wsManager.on('max-reconnect-attempts', (data) => {\n      this.showErrorState('Unable to connect to server after multiple attempts. Please refresh the page.');\n      this.showNotification('Connection failed - please refresh the page', 'error');\n      this.trackEvent('websocket_max_reconnect_attempts', data);\n    });\n    \n    this.wsManager.on('error', (error) => {\n      console.error('WebSocket error:', error);\n      this.trackEvent('websocket_error', { error: error.message });\n      this.showNotification(`WebSocket error: ${error.message}`, 'error');\n    });\n    \n    this.wsManager.on('server-unresponsive', () => {\n      console.warn('Server appears unresponsive');\n      this.updateConnectionStatus('reconnecting');\n      this.showNotification('Server unresponsive - reconnecting...', 'warning');\n    });\n    \n    // Message handling events\n    this.wsManager.on('message', (data) => {\n      this.handleMessage(data);\n    });\n    \n    // Specific message type handlers\n    this.wsManager.on('connection-established', (data) => {\n      this.handleConnectionEstablished(data);\n    });\n    \n    this.wsManager.on('initial-state', (data) => {\n      this.loadSessions(data.sessions);\n    });\n    \n    this.wsManager.on('log', (data) => {\n      this.appendLog(data.sessionId, data.log);\n    });\n    \n    this.wsManager.on('server-ready', (data) => {\n      this.updateSession(data.session);\n      this.showNotification(`Server ready: ${data.session.name}`, 'success');\n    });\n    \n    this.wsManager.on('process-exit', (data) => {\n      this.handleProcessExit(data.sessionId, data.code, data.signal);\n    });\n    \n    this.wsManager.on('process-error', (data) => {\n      this.handleProcessError(data.sessionId, data.error);\n    });\n    \n    this.wsManager.on('logs-response', (data) => {\n      this.handleLogsResponse(data.sessionId, data.logs);\n    });\n    \n    this.wsManager.on('logs-cleared', (data) => {\n      this.handleLogsCleared(data.sessionId);\n      this.showNotification('Logs cleared', 'info');\n    });\n    \n    this.wsManager.on('queued-messages-received', (data) => {\n      console.log(`Received ${data.count} queued messages`);\n      this.showNotification(`Received ${data.count} queued messages`, 'info');\n    });\n    \n    this.wsManager.on('server-shutdown', (data) => {\n      this.showNotification('Server is shutting down', 'warning');\n      console.log('Server shutdown notification:', data);\n    });\n    \n    this.wsManager.on('subscription-confirmed', (data) => {\n      console.log('Subscription confirmed:', data);\n      this.showNotification(`Subscribed to ${data.sessionId}`, 'success');\n    });\n  }\n  \n  /**\n   * Handle connection established event with enhanced features\n   */\n  handleConnectionEstablished(data) {\n    console.log('Connection established:', data);\n    \n    // Update UI with connection details\n    const statusElement = document.querySelector('.connection-status');\n    if (statusElement && data.clientId) {\n      statusElement.title = `Client ID: ${data.clientId}\\n` +\n                            `Authenticated: ${data.authenticated}\\n` +\n                            `Server Capabilities: ${JSON.stringify(data.serverCapabilities, null, 2)}`;\n    }\n    \n    // Show capabilities in console\n    if (data.serverCapabilities) {\n      console.log('Server capabilities:', data.serverCapabilities);\n    }\n  }\n  \n  /**\n   * Enhanced message handling with comprehensive error handling\n   */\n  handleMessage(data) {\n    this.performanceMetrics.messagesReceived++;\n    this.performanceMetrics.lastMessageTime = Date.now();\n    \n    // Handle generic message types that don't have specific handlers\n    switch (data.type) {\n      case 'hook-notification':\n        this.handleHookNotification(data.payload || data.data);\n        break;\n        \n      case 'error':\n        console.error('Server error:', data.error);\n        this.showNotification(`Server error: ${data.error}`, 'error');\n        break;\n        \n      case 'authentication-success':\n        console.log('Authentication successful');\n        this.showNotification('Authentication successful', 'success');\n        break;\n        \n      case 'authentication-failed':\n        console.error('Authentication failed:', data.error);\n        this.showNotification(`Authentication failed: ${data.error}`, 'error');\n        break;\n        \n      default:\n        // Let specific event handlers deal with their types\n        break;\n    }\n  }\n  \n  /**\n   * Enhanced session selection with subscription support\n   */\n  async selectSession(sessionId) {\n    if (this.selectedSessionId === sessionId) {\n      return; // Already selected\n    }\n    \n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      console.warn('Attempted to select non-existent session:', sessionId);\n      return;\n    }\n    \n    // Unsubscribe from previous session\n    if (this.selectedSessionId) {\n      try {\n        await this.send({\n          type: 'unsubscribe',\n          payload: {\n            sessionId: this.selectedSessionId,\n            eventTypes: ['log', 'server-ready', 'process-exit', 'process-error']\n          }\n        }, { requireAck: true });\n      } catch (error) {\n        console.warn('Failed to unsubscribe from previous session:', error);\n      }\n    }\n    \n    this.selectedSessionId = sessionId;\n    this.renderSessions();\n    this.updateLogSessionInfo(session);\n    this.renderAllLogs();\n    \n    // Subscribe to new session events\n    try {\n      await this.send({\n        type: 'subscribe',\n        payload: {\n          sessionId,\n          eventTypes: ['log', 'server-ready', 'process-exit', 'process-error']\n        }\n      }, { requireAck: true });\n      \n      console.log('Subscribed to session:', sessionId);\n    } catch (error) {\n      console.error('Failed to subscribe to session:', error);\n      this.showNotification('Failed to subscribe to session updates', 'warning');\n    }\n    \n    // Request fresh logs from server with acknowledgment\n    await this.requestSessionLogs(sessionId);\n    \n    // Track session selection\n    this.trackEvent('session_selected', { \n      sessionId, \n      sessionName: session.name,\n      framework: session.framework \n    });\n  }\n  \n  /**\n   * Send WebSocket message using enhanced manager with robust error handling\n   */\n  async send(data, options = {}) {\n    if (!this.wsManager) {\n      const error = new Error('WebSocket manager not initialized');\n      console.warn('WebSocket manager not initialized, message not sent:', data);\n      return Promise.reject(error);\n    }\n    \n    try {\n      return await this.wsManager.send(data, options);\n    } catch (error) {\n      console.error('Failed to send WebSocket message:', error);\n      this.showNotification('Communication error - message not sent', 'error');\n      throw error;\n    }\n  }\n\n  /**\n   * Request logs for a specific session with enhanced error handling\n   */\n  async requestSessionLogs(sessionId, options = {}) {\n    try {\n      const startTime = Date.now();\n      \n      await this.send({\n        type: 'get-logs',\n        payload: {\n          sessionId,\n          options: { tail: 500, ...options }\n        }\n      }, { requireAck: true, timeout: 10000 });\n      \n      const latency = Date.now() - startTime;\n      console.log(`Logs requested for ${sessionId} (${latency}ms)`);\n      \n    } catch (error) {\n      console.error('Failed to request session logs:', error);\n      this.showNotification('Failed to load session logs', 'error');\n      throw error;\n    }\n  }\n  \n  /**\n   * Enhanced connection status update with detailed metrics\n   */\n  updateConnectionStatus(state) {\n    const statusElement = document.querySelector('.connection-status');\n    const statusDot = document.querySelector('.status-dot');\n    const statusText = document.querySelector('.status-text');\n    \n    if (!statusElement || !statusDot || !statusText) {\n      console.warn('Connection status elements not found');\n      return;\n    }\n    \n    // Remove all status classes\n    statusElement.classList.remove('connected', 'connecting', 'disconnected', 'reconnecting');\n    statusDot.classList.remove('connected');\n    \n    const wsStatus = this.wsManager ? this.wsManager.getStatus() : {};\n    \n    switch (state) {\n      case 'connected':\n        statusElement.classList.add('connected');\n        statusDot.classList.add('connected');\n        statusText.textContent = 'Connected';\n        if (wsStatus.authenticated) {\n          statusText.textContent += ' ✓';\n        }\n        break;\n      case 'connecting':\n        statusElement.classList.add('connecting');\n        statusText.textContent = 'Connecting...';\n        break;\n      case 'reconnecting':\n        statusElement.classList.add('reconnecting');\n        statusText.textContent = `Reconnecting... (${wsStatus.reconnectAttempts || 0})`;\n        break;\n      case 'disconnected':\n        statusElement.classList.add('disconnected');\n        statusText.textContent = 'Disconnected';\n        break;\n      default:\n        statusText.textContent = 'Unknown';\n    }\n    \n    this.connectionState = state;\n    \n    // Update tooltip with comprehensive status information\n    if (this.wsManager) {\n      const status = this.wsManager.getStatus();\n      statusElement.title = `State: ${status.connectionState}\\n` +\n        `Client ID: ${status.clientId || 'N/A'}\\n` +\n        `Authenticated: ${status.authenticated}\\n` +\n        `Reconnect Attempts: ${status.reconnectAttempts}\\n` +\n        `Queued Messages: ${status.queuedMessages}\\n` +\n        `Pending Acks: ${status.pendingAcks}\\n` +\n        `Messages Sent: ${status.metrics.messagesSent}\\n` +\n        `Messages Received: ${status.metrics.messagesReceived}\\n` +\n        `Bytes Sent: ${this.formatBytes(status.metrics.bytesSent)}\\n` +\n        `Bytes Received: ${this.formatBytes(status.metrics.bytesReceived)}\\n` +\n        `Avg Latency: ${Math.round(status.metrics.avgLatency)}ms\\n` +\n        `Last Latency: ${Math.round(status.metrics.lastLatency)}ms\\n` +\n        `Server Responding: ${status.serverResponding}`;\n    }\n  }\n  \n  /**\n   * Enhanced notification system\n   */\n  showNotification(message, type = 'info', duration = 5000) {\n    // Remove old notifications if queue is full\n    while (this.notificationQueue.length >= this.maxNotifications) {\n      const oldNotification = this.notificationQueue.shift();\n      if (oldNotification.element && oldNotification.element.parentNode) {\n        oldNotification.element.remove();\n      }\n    }\n    \n    const notification = document.createElement('div');\n    notification.className = `notification notification-${type}`;\n    notification.innerHTML = `\n      <div class=\"notification-content\">\n        <span class=\"notification-icon\">${this.getNotificationIcon(type)}</span>\n        <span class=\"notification-message\">${this.escapeHtml(message)}</span>\n        <button class=\"notification-close\">×</button>\n      </div>\n    `;\n    \n    // Add to notification container\n    let container = document.getElementById('notificationContainer');\n    if (!container) {\n      container = document.createElement('div');\n      container.id = 'notificationContainer';\n      container.className = 'notification-container';\n      document.body.appendChild(container);\n    }\n    \n    container.appendChild(notification);\n    \n    // Add to queue\n    const notificationObj = { element: notification, type, message };\n    this.notificationQueue.push(notificationObj);\n    \n    // Auto-remove after duration\n    const timeoutId = setTimeout(() => {\n      this.removeNotification(notificationObj);\n    }, duration);\n    \n    // Handle manual close\n    const closeBtn = notification.querySelector('.notification-close');\n    closeBtn.addEventListener('click', () => {\n      clearTimeout(timeoutId);\n      this.removeNotification(notificationObj);\n    });\n    \n    // Animate in\n    requestAnimationFrame(() => {\n      notification.classList.add('notification-show');\n    });\n  }\n  \n  /**\n   * Remove notification from queue and DOM\n   */\n  removeNotification(notificationObj) {\n    const index = this.notificationQueue.indexOf(notificationObj);\n    if (index > -1) {\n      this.notificationQueue.splice(index, 1);\n    }\n    \n    if (notificationObj.element && notificationObj.element.parentNode) {\n      notificationObj.element.classList.add('notification-hide');\n      setTimeout(() => {\n        if (notificationObj.element.parentNode) {\n          notificationObj.element.remove();\n        }\n      }, 300);\n    }\n  }\n  \n  /**\n   * Get notification icon based on type\n   */\n  getNotificationIcon(type) {\n    switch (type) {\n      case 'success': return '✅';\n      case 'error': return '❌';\n      case 'warning': return '⚠️';\n      case 'info': return 'ℹ️';\n      default: return '📢';\n    }\n  }\n  \n  /**\n   * Format bytes for display\n   */\n  formatBytes(bytes) {\n    if (bytes === 0) return '0 B';\n    const k = 1024;\n    const sizes = ['B', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n  \n  /**\n   * Enhanced clear session logs with confirmation and feedback\n   */\n  async clearSessionLogs() {\n    if (!this.selectedSessionId) {\n      this.showNotification('Please select a session first', 'warning');\n      return;\n    }\n\n    if (!confirm('Clear all logs for this session? This action cannot be undone.')) {\n      return;\n    }\n\n    try {\n      await this.send({\n        type: 'clear-logs',\n        payload: { sessionId: this.selectedSessionId }\n      }, { requireAck: true, timeout: 5000 });\n      \n      this.showNotification('Logs cleared successfully', 'success');\n    } catch (error) {\n      console.error('Failed to clear logs:', error);\n      this.showNotification('Failed to clear logs', 'error');\n    }\n  }\n  \n  // Import the rest of the methods from the original app.js\n  // (keeping the core functionality intact while adding WebSocket enhancements)\n  \n  loadSessions(sessions) {\n    this.sessions.clear();\n    sessions.forEach(session => {\n      this.sessions.set(session.id, session);\n    });\n    this.renderSessions();\n    this.updateSessionCount();\n  }\n  \n  updateSession(sessionData) {\n    const session = this.sessions.get(sessionData.id);\n    if (session) {\n      Object.assign(session, sessionData);\n    } else {\n      this.sessions.set(sessionData.id, sessionData);\n    }\n    this.renderSessions();\n    this.updateSessionCount();\n  }\n  \n  appendLog(sessionId, log) {\n    if (!this.logBuffer.has(sessionId)) {\n      this.logBuffer.set(sessionId, []);\n    }\n    \n    const logs = this.logBuffer.get(sessionId);\n    logs.push(log);\n    \n    // Keep only last 2000 logs per session\n    if (logs.length > 2000) {\n      logs.shift();\n    }\n    \n    // Update UI if this session is selected\n    if (sessionId === this.selectedSessionId) {\n      this.renderLog(log);\n      if (this.autoScroll) {\n        this.scrollToBottom();\n      }\n    }\n  }\n  \n  renderSessions() {\n    const grid = document.getElementById('sessionsGrid');\n    const noSessions = document.getElementById('noSessions');\n    \n    if (this.sessions.size === 0) {\n      grid.innerHTML = '';\n      grid.appendChild(noSessions);\n      return;\n    }\n    \n    // Remove no-sessions placeholder\n    if (noSessions.parentNode) {\n      noSessions.remove();\n    }\n    \n    grid.innerHTML = '';\n    \n    this.sessions.forEach(session => {\n      const card = this.createSessionCard(session);\n      grid.appendChild(card);\n    });\n  }\n  \n  createSessionCard(session) {\n    const card = document.createElement('div');\n    card.className = 'session-card';\n    if (session.id === this.selectedSessionId) {\n      card.classList.add('selected');\n    }\n    \n    const uptime = this.formatUptime(session.uptime);\n    \n    card.innerHTML = `\n      <div class=\"session-header\">\n        <div>\n          <div class=\"session-name\">${this.escapeHtml(session.name)}</div>\n          <div class=\"session-command\">${this.escapeHtml(session.command)}</div>\n        </div>\n        <div class=\"session-status ${session.status}\">\n          <span class=\"status-dot\"></span>\n          ${session.status}\n        </div>\n      </div>\n      <div class=\"session-meta\">\n        <span>Framework: ${session.framework || 'unknown'}</span>\n        <span>Port: ${session.port}</span>\n        <span>PID: ${session.pid || 'N/A'}</span>\n        <span>Uptime: ${uptime}</span>\n      </div>\n      <div class=\"session-actions\">\n        <button class=\"btn btn-primary\" onclick=\"app.selectSession('${session.id}')\">\n          📋 View Logs\n        </button>\n        ${session.status === 'running' ? `\n          <a href=\"http://localhost:${session.port}\" target=\"_blank\" class=\"btn btn-success\">\n            🌐 Open App\n          </a>\n          <button class=\"btn btn-secondary\" onclick=\"app.restartSession('${session.id}')\">\n            🔄 Restart\n          </button>\n          <button class=\"btn btn-secondary\" onclick=\"app.configureSession('${session.id}')\">\n            ⚙️ Configure\n          </button>\n          <button class=\"btn btn-secondary\" onclick=\"app.healthCheckSession('${session.id}')\">\n            🏥 Health\n          </button>\n          <button class=\"btn btn-danger\" onclick=\"app.stopSession('${session.id}')\">\n            ⏹️ Stop\n          </button>\n          <button class=\"btn btn-danger\" onclick=\"app.forceStopSession('${session.id}')\">\n            🚫 Force Stop\n          </button>\n        ` : session.status === 'stopped' || session.status === 'error' ? `\n          <button class=\"btn btn-secondary\" onclick=\"app.restartSession('${session.id}')\">\n            🔄 Restart\n          </button>\n          <button class=\"btn btn-secondary\" onclick=\"app.configureSession('${session.id}')\">\n            ⚙️ Configure\n          </button>\n        ` : ''}\n      </div>\n    `;\n    \n    // Add click handler for card selection\n    card.addEventListener('click', (e) => {\n      if (!e.target.closest('.session-actions')) {\n        this.selectSession(session.id);\n      }\n    });\n    \n    return card;\n  }\n  \n  handleProcessExit(sessionId, code, signal) {\n    const session = this.sessions.get(sessionId);\n    if (session) {\n      session.status = 'stopped';\n      session.exitCode = code;\n      session.exitSignal = signal;\n      this.renderSessions();\n      \n      this.showNotification(`Process exited: ${session.name} (code: ${code})`, \n        code === 0 ? 'info' : 'warning');\n    }\n  }\n  \n  handleProcessError(sessionId, error) {\n    const session = this.sessions.get(sessionId);\n    if (session) {\n      session.status = 'error';\n      session.error = error;\n      this.renderSessions();\n      \n      this.showNotification(`Process error: ${session.name} - ${error}`, 'error');\n    }\n  }\n  \n  handleHookNotification(data) {\n    console.log('Hook notification:', data);\n    this.showNotification(`Hook: ${data.type || 'notification'}`, 'info');\n  }\n  \n  handleLogsResponse(sessionId, logs) {\n    this.logBuffer.set(sessionId, logs);\n    if (sessionId === this.selectedSessionId) {\n      this.renderAllLogs();\n    }\n  }\n  \n  handleLogsCleared(sessionId) {\n    this.logBuffer.delete(sessionId);\n    if (sessionId === this.selectedSessionId) {\n      this.clearLogDisplay();\n    }\n  }\n  \n  renderAllLogs() {\n    const content = document.getElementById('logContent');\n    const logs = this.logBuffer.get(this.selectedSessionId) || [];\n    \n    if (logs.length === 0) {\n      content.innerHTML = '<div class=\"log-placeholder\">No logs yet for this session</div>';\n      return;\n    }\n    \n    content.innerHTML = '';\n    logs.forEach(log => this.renderLog(log));\n    \n    if (this.autoScroll) {\n      this.scrollToBottom();\n    }\n  }\n  \n  renderLog(log) {\n    const content = document.getElementById('logContent');\n    \n    // Remove placeholder if present\n    const placeholder = content.querySelector('.log-placeholder');\n    if (placeholder) {\n      placeholder.remove();\n    }\n    \n    const entry = document.createElement('div');\n    entry.className = `log-entry ${log.type}`;\n    \n    const timestamp = new Date(log.timestamp).toLocaleTimeString();\n    entry.innerHTML = `\n      <span class=\"log-timestamp\">${timestamp}</span>\n      <span class=\"log-data\">${this.escapeHtml(log.data)}</span>\n    `;\n    \n    content.appendChild(entry);\n    \n    // Keep max 1000 DOM elements\n    const entries = content.querySelectorAll('.log-entry');\n    if (entries.length > 1000) {\n      entries[0].remove();\n    }\n  }\n  \n  clearLogDisplay() {\n    const content = document.getElementById('logContent');\n    content.innerHTML = '<div class=\"log-placeholder\">Logs cleared</div>';\n  }\n  \n  scrollToBottom() {\n    const content = document.getElementById('logContent');\n    content.scrollTop = content.scrollHeight;\n  }\n  \n  formatUptime(ms) {\n    if (!ms || ms < 0) return 'Unknown';\n    \n    const seconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n    \n    if (days > 0) {\n      return `${days}d ${hours % 24}h ${minutes % 60}m`;\n    } else if (hours > 0) {\n      return `${hours}h ${minutes % 60}m`;\n    } else if (minutes > 0) {\n      return `${minutes}m ${seconds % 60}s`;\n    } else {\n      return `${seconds}s`;\n    }\n  }\n  \n  escapeHtml(text) {\n    if (typeof text !== 'string') {\n      return String(text);\n    }\n    \n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n  }\n  \n  updateSessionCount() {\n    const countElement = document.getElementById('sessionCount');\n    const count = this.sessions.size;\n    countElement.textContent = `${count} session${count !== 1 ? 's' : ''}`;\n  }\n  \n  updateLogSessionInfo(session) {\n    const infoElement = document.getElementById('logSessionInfo');\n    if (infoElement && session) {\n      infoElement.innerHTML = `\n        <span>Session: ${this.escapeHtml(session.name)}</span>\n        <span>Port: ${session.port}</span>\n        <span>Framework: ${session.framework || 'Unknown'}</span>\n        <span>Status: ${session.status}</span>\n      `;\n    }\n  }\n  \n  showLoadingState() {\n    const container = document.querySelector('.container');\n    if (container) {\n      container.classList.add('loading');\n    }\n  }\n  \n  hideLoadingState() {\n    const container = document.querySelector('.container');\n    if (container) {\n      container.classList.remove('loading');\n    }\n  }\n  \n  showErrorState(message) {\n    const container = document.querySelector('.container');\n    if (container) {\n      const errorDiv = document.createElement('div');\n      errorDiv.className = 'error-state';\n      errorDiv.innerHTML = `\n        <div class=\"error-content\">\n          <h3>⚠️ ${message}</h3>\n          <button onclick=\"window.location.reload()\" class=\"btn btn-primary\">\n            🔄 Reload Page\n          </button>\n        </div>\n      `;\n      container.appendChild(errorDiv);\n    }\n  }\n  \n  async loadInitialState() {\n    try {\n      const response = await fetch('/api/sessions');\n      if (response.ok) {\n        const data = await response.json();\n        this.loadSessions(data.sessions);\n      }\n    } catch (error) {\n      console.error('Error loading initial state:', error);\n      throw error;\n    }\n  }\n  \n  async stopSession(sessionId) {\n    if (!confirm('Are you sure you want to stop this server?')) {\n      return;\n    }\n    \n    try {\n      const response = await fetch(`/api/sessions/${sessionId}/stop`, {\n        method: 'POST'\n      });\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      const result = await response.json();\n      console.log('Session stopped:', result);\n      this.showNotification('Session stopped successfully', 'success');\n    } catch (error) {\n      console.error('Error stopping session:', error);\n      this.showNotification(`Failed to stop session: ${error.message}`, 'error');\n    }\n  }\n  \n  async restartSession(sessionId) {\n    if (!confirm('Are you sure you want to restart this server?')) {\n      return;\n    }\n    \n    try {\n      const response = await fetch(`/api/sessions/${sessionId}/restart`, {\n        method: 'POST'\n      });\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      const result = await response.json();\n      console.log('Session restarted:', result);\n      this.showNotification('Session restart initiated', 'success');\n    } catch (error) {\n      console.error('Error restarting session:', error);\n      this.showNotification(`Failed to restart session: ${error.message}`, 'error');\n    }\n  }\n  \n  bindEvents() {\n    // Header buttons\n    this.bindElement('refreshBtn', 'click', () => this.refreshSessions());\n    this.bindElement('settingsBtn', 'click', () => this.toggleSettings());\n    \n    // Log controls\n    this.bindElement('clearLogs', 'click', () => this.clearSessionLogs());\n    this.bindElement('exportLogs', 'click', () => this.exportSessionLogs());\n    \n    // Auto-scroll toggle\n    this.bindElement('autoScroll', 'click', (e) => {\n      this.autoScroll = !this.autoScroll;\n      e.target.classList.toggle('active', this.autoScroll);\n      \n      if (this.autoScroll) {\n        this.scrollToBottom();\n      }\n      \n      this.trackEvent('auto_scroll_toggled', { enabled: this.autoScroll });\n    });\n  }\n  \n  bindElement(elementId, event, handler) {\n    const element = document.getElementById(elementId);\n    if (element) {\n      element.addEventListener(event, handler);\n    } else {\n      console.warn(`Element not found: ${elementId}`);\n    }\n  }\n  \n  async refreshSessions() {\n    try {\n      const response = await fetch('/api/sessions');\n      if (response.ok) {\n        const data = await response.json();\n        this.loadSessions(data.sessions);\n        this.showNotification('Sessions refreshed', 'success');\n      }\n    } catch (error) {\n      console.error('Error refreshing sessions:', error);\n      this.showNotification('Failed to refresh sessions', 'error');\n    }\n  }\n  \n  toggleSettings() {\n    console.log('Settings panel - enhanced version to be implemented');\n    this.showNotification('Settings panel coming soon', 'info');\n  }\n  \n  async exportSessionLogs() {\n    if (!this.selectedSessionId) {\n      this.showNotification('Please select a session first', 'warning');\n      return;\n    }\n\n    try {\n      const response = await fetch(`/api/sessions/${this.selectedSessionId}/export?format=txt`);\n      if (response.ok) {\n        const blob = await response.blob();\n        const url = window.URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = `logs-${this.selectedSessionId}-${new Date().toISOString().split('T')[0]}.txt`;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        window.URL.revokeObjectURL(url);\n        \n        this.showNotification('Logs exported successfully', 'success');\n      }\n    } catch (error) {\n      console.error('Error exporting logs:', error);\n      this.showNotification('Failed to export logs', 'error');\n    }\n  }\n  \n  startPeriodicUpdates() {\n    // Refresh session data every 30 seconds (only when page is visible)\n    this.periodicUpdateInterval = setInterval(async () => {\n      if (document.hidden) {\n        return; // Skip updates when tab is hidden\n      }\n      \n      try {\n        await this.refreshSessions();\n      } catch (error) {\n        console.error('Error in periodic update:', error);\n      }\n    }, 30000);\n    \n    // Performance metrics update every 60 seconds\n    this.metricsUpdateInterval = setInterval(() => {\n      this.updatePerformanceMetrics();\n    }, 60000);\n  }\n  \n  updatePerformanceMetrics() {\n    if (this.wsManager) {\n      const status = this.wsManager.getStatus();\n      this.performanceMetrics = {\n        ...this.performanceMetrics,\n        ...status.metrics,\n        connectionUptime: status.lastConnectionTime ? Date.now() - status.lastConnectionTime : 0\n      };\n    }\n  }\n  \n  trackEvent(eventName, data = {}) {\n    const event = {\n      name: eventName,\n      timestamp: Date.now(),\n      userAgent: navigator.userAgent,\n      url: window.location.href,\n      wsStatus: this.wsManager ? this.wsManager.getStatus() : null,\n      ...data\n    };\n\n    // Enhanced analytics with WebSocket metrics\n    console.debug('Event tracked:', event);\n    \n    // Future: Send to analytics service via WebSocket\n    // this.send({ type: 'analytics-event', payload: event });\n  }\n}\n\n// Initialize app when DOM is ready\ndocument.addEventListener('DOMContentLoaded', () => {\n  try {\n    window.app = new DashboardApp();\n  } catch (error) {\n    console.error('Failed to initialize Enhanced DashboardApp:', error);\n    \n    // Show enhanced error message\n    document.body.innerHTML = `\n      <div style=\"\n        position: fixed;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        background: #1e293b;\n        color: #f1f5f9;\n        padding: 40px;\n        border-radius: 12px;\n        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);\n        text-align: center;\n        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n        max-width: 500px;\n      \">\n        <h2 style=\"color: #ef4444; margin-bottom: 16px;\">⚠️ Enhanced Dashboard Error</h2>\n        <p style=\"margin-bottom: 20px; color: #94a3b8;\">Failed to initialize the MCP Debug Host Dashboard with enhanced WebSocket features.</p>\n        <details style=\"margin-bottom: 20px; text-align: left; background: #0f172a; padding: 12px; border-radius: 6px;\">\n          <summary style=\"cursor: pointer; color: #3b82f6;\">Error Details</summary>\n          <pre style=\"margin-top: 8px; font-size: 12px; color: #ef4444;\">${error.message}\\n${error.stack}</pre>\n        </details>\n        <button \n          onclick=\"window.location.reload()\" \n          style=\"\n            background: #2563eb;\n            color: white;\n            border: none;\n            padding: 12px 24px;\n            border-radius: 8px;\n            cursor: pointer;\n            font-weight: 500;\n            margin-right: 12px;\n          \"\n        >🔄 Reload Page</button>\n        <button \n          onclick=\"window.history.back()\" \n          style=\"\n            background: #64748b;\n            color: white;\n            border: none;\n            padding: 12px 24px;\n            border-radius: 8px;\n            cursor: pointer;\n            font-weight: 500;\n          \"\n        >⬅️ Go Back</button>\n      </div>\n    `;\n  }\n});